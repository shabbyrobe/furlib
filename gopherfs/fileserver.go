package gopherfs

import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"path"
	"sort"
	"strings"
	"unicode/utf8"

	"github.com/shabbyrobe/furlib/gopher"
)

// FileServer returns a handler that serves Gopher requests with the contents of the file
// system rooted at root.
//
type FileServer struct {
	fs   FileSystem
	base string

	MinPerms os.FileMode
	AllowDot bool
	Log      gopher.Logger

	// Rewrite allows you to intercept the selector and manipulate it. You must return
	// the original selector if you don't wish to change it. If allowed is not true,
	// the resource will appear to not exist.
	Rewrite func(selector string) (out string, allowed bool)

	// Change the file name used to represent the gophermap for a directory. Defaults to
	// 'gophermap'.
	GopherMapFile string

	// If the gophermap is autogenerated, the contents of this file is prepended as 'i'
	// lines. Defaults to 'gopherbanner'.
	BannerFile string

	// ItemType is called first in the chain of type resolvers. It allows you full control
	// of the item type for a given selector.
	//
	// Return 'gopher.NoItemType, true' if you want to fall back to the default matching.
	// The selector can be used directly with your FileSystem implementation if you want
	// to inspect the file.
	//
	// Return 'gopher.NoItemType, false' if you want the FileServer to pretend the
	// selector does not exist.
	ItemType func(selector string) (item gopher.ItemType, allowed bool)

	// ExtensionTypes is used to look up the ItemType by file extension (including the
	// leading '.') if ItemType is not set or returns gopher.NoItemType.
	ExtensionTypes map[string]gopher.ItemType
}

var _ gopher.Handler = &FileServer{}
var _ gopher.MetaHandler = &FileServer{}

func New(fs FileSystem, base string) *FileServer {
	return &FileServer{
		fs:            fs,
		base:          path.Clean(base),
		GopherMapFile: "gophermap",
		BannerFile:    "gopherbanner",
	}
}

func (fsrv *FileServer) ServeGopher(ctx context.Context, w gopher.ResponseWriter, r *gopher.Request) {
	u := r.URL()

	selector, allowed := fsrv.handleSelector(u.Selector)
	if !allowed {
		respondError(w, r, gopher.StatusNotFound, "Error: Not found")
		return
	}

	file, err := fsrv.fs.Open(selector)
	if err != nil {
		code, msg := toGopherError(err)
		respondError(w, r, code, msg) // FIXME: allow logging
		return
	}
	defer file.Close()

	st, err := file.Stat()
	if err != nil {
		code, msg := toGopherError(err)
		respondError(w, r, code, msg) // FIXME: allow logging
		return
	}

	if st.IsDir() {
		if fsrv.GopherMapFile != "" {
			gopherMapPath := path.Join(selector, fsrv.GopherMapFile)
			gmap, err := fsrv.fs.Open(gopherMapPath)
			if err == nil {
				defer gmap.Close()
				fsrv.copyGopherMap(ctx, gmap, w, r)
				return
			}
		}
		fsrv.buildGopherMap(ctx, file, selector, w, r)
		return
	}

	itemType, allowed := fsrv.findItemType(selector)
	if !allowed {
		respondError(w, r, gopher.StatusNotFound, "Error: Not found")
		return
	}

	var outWriter io.Writer
	if itemType.IsBinary() {
		outWriter = w

	} else {
		tw := gopher.NewTextWriter(w)
		defer tw.MustFlush()
		outWriter = tw
	}
	if _, err := io.Copy(outWriter, file); err != nil {
		_ = err // FIXME: log
		return
	}
}

func (fsrv *FileServer) ServeGopherMeta(ctx context.Context, w gopher.MetaWriter, r *gopher.Request) {
	u := r.URL()

	selector, allowed := fsrv.handleSelector(u.Selector)
	if !allowed {
		w.MetaError(gopher.StatusNotFound, "Error: not found")
		return
	}

	f, err := fsrv.fs.Open(selector)
	if err != nil {
		w.MetaError(gopher.StatusNotFound, err.Error())
		return
	}
	defer f.Close()

	itemType, allowed := fsrv.findItemType(selector)
	if !allowed {
		w.MetaError(gopher.StatusNotFound, err.Error())
		return
	}

	// FIXME: get item display name from directory's gophermap
	w.Info(itemType, u.Selector, u.Selector)
}

func (fsrv *FileServer) copyGopherMap(ctx context.Context, file File, w io.Writer, r *gopher.Request) error {
	// FIXME: could maybe skip invalid dirents and continue rather than aborting
	// on the first:
	var dirent gopher.Dirent
	rqSel := r.URL().Selector
	dirR := gopher.NewDirReader(file)
	dirR.Flag = gopher.DirentHostOptional
	dirW := gopher.NewDirWriter(w, r)
	defer dirW.MustFlush()
	for dirR.Read(&dirent) {
		dirent.Selector = path.Join(fsrv.base, rqSel, dirent.Selector)
		if dirent.Hostname == "" {
			dirW.Selector(dirent.ItemType, dirent.Display, dirent.Selector)
		} else {
			dirW.Dirent(&dirent)
		}
	}
	return dirR.ReadErr()
}

func (fsrv *FileServer) buildGopherMap(ctx context.Context, file File, sel string, w io.Writer, r *gopher.Request) error {
	dirW := gopher.NewDirWriter(w, r)

	if fsrv.BannerFile != "" {
		banner, err := fsrv.fs.Open(path.Clean(path.Join(sel, fsrv.BannerFile)))
		if err == nil {
			scn := bufio.NewScanner(banner)
			for scn.Scan() {
				dirW.Info(scn.Text())
			}
			banner.Close()
		}
	}

	if sel != "" && sel != "/" {
		parent := path.Dir(sel)
		if parent == "." {
			parent = ""
		}
		dirW.Selector(gopher.Dir, "..", parent)
	}

	for {
		entries, err := file.Readdir(1024)
		if len(entries) == 0 && err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		var sorted files = entries
		sort.Sort(sorted)

		for _, e := range entries {
			name := e.Name()
			if len(name) == 0 ||
				(!fsrv.AllowDot && name[0] == '.') ||
				name == fsrv.GopherMapFile ||
				name == fsrv.BannerFile {
				continue
			}

			full := path.Join(fsrv.base, sel, name)

			var it gopher.ItemType
			var allowed bool

			if e.IsDir() {
				it = gopher.Dir
			} else {
				it, allowed = fsrv.findItemType(full)
				if !allowed {
					continue
				}
			}

			dirW.Selector(it, name, full)
		}
	}

	return dirW.Flush()
}

func (fsrv *FileServer) handleSelector(selector string) (out string, allowed bool) {
	allowed = true
	if fsrv.Rewrite != nil {
		selector, allowed = fsrv.Rewrite(selector)
	}
	out = path.Clean(selector)
	if out == "." {
		out = ""
	}
	return out, allowed
}

func (fsrv *FileServer) findItemType(selector string) (item gopher.ItemType, allowed bool) {
	if fsrv.ItemType != nil {
		it, allowed := fsrv.ItemType(selector)
		if it != gopher.NoItemType || !allowed {
			return it, allowed
		}
	}

	if fsrv.ExtensionTypes != nil {
		item, ok := fsrv.ExtensionTypes[strings.ToLower(path.Ext(selector))]
		if ok {
			return item, true
		}
	}

	item, ok := defaultExtensionTypes[strings.ToLower(path.Ext(selector))]
	if ok {
		return item, true
	}

	// XXX: Crap Text/Binary detection heuristic; this will need to be dealt with
	// at some point. If the first 2k is valid utf8, it's text, otherwise it's binary.

	f, err := fsrv.fs.Open(selector)
	if err != nil {
		// We presume we've tried to open/stat this already, and just do this for
		// safety's sake:
		return gopher.Binary, true
	}
	defer f.Close()

	buf := make([]byte, 2048)
	n, _ := f.Read(buf)
	for i := 0; i < n; {
		r, w := utf8.DecodeRune(buf[:n])
		i += w
		if r == utf8.RuneError && i+4 < n {
			return gopher.Binary, true
		}
	}
	return gopher.Text, true
}

func respondError(w gopher.ResponseWriter, r *gopher.Request, code gopher.Status, msg string) {
	dw := gopher.NewDirWriter(w, r)
	defer dw.MustFlush()
	dw.Error(fmt.Sprintf("Error: %d %s", code, msg))
}

func toGopherError(err error) (status gopher.Status, msg string) {
	if errors.Is(err, os.ErrNotExist) {
		return gopher.StatusNotFound, "Page not found"
	}
	if errors.Is(err, os.ErrPermission) {
		return gopher.StatusForbidden, "Forbidden"
	}
	return gopher.StatusInternal, "Internal Server Error"
}

type files []os.FileInfo

func (f files) Len() int { return len(f) }

func (f files) Less(i, j int) bool {
	idir, jdir := f[i].IsDir(), f[j].IsDir()
	if idir == jdir {
		return f[i].Name() < f[j].Name()
	} else if idir {
		return true
	}
	return false
}

func (f files) Swap(i, j int) {
	f[i], f[j] = f[j], f[i]
}
